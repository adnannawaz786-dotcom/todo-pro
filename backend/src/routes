const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const todoController = require('../controllers/todoController');
const userController = require('../controllers/userController');
const auth = require('../middleware/auth');
const rateLimit = require('express-rate-limit');
const { body } = require('express-validator');

// Rate limiting configurations
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: {
    error: 'Too many authentication attempts, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: {
    error: 'Too many requests, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Validation middleware
const registerValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email'),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),
  body('name')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Name must be between 2 and 50 characters')
];

const loginValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email'),
  body('password')
    .notEmpty()
    .withMessage('Password is required')
];

const todoValidation = [
  body('title')
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Title must be between 1 and 200 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must not exceed 1000 characters'),
  body('priority')
    .optional()
    .isIn(['low', 'medium', 'high'])
    .withMessage('Priority must be low, medium, or high'),
  body('dueDate')
    .optional()
    .isISO8601()
    .withMessage('Due date must be a valid date'),
  body('category')
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage('Category must not exceed 50 characters')
];

const updateTodoValidation = [
  body('title')
    .optional()
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Title must be between 1 and 200 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must not exceed 1000 characters'),
  body('priority')
    .optional()
    .isIn(['low', 'medium', 'high'])
    .withMessage('Priority must be low, medium, or high'),
  body('dueDate')
    .optional()
    .isISO8601()
    .withMessage('Due date must be a valid date'),
  body('category')
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage('Category must not exceed 50 characters'),
  body('completed')
    .optional()
    .isBoolean()
    .withMessage('Completed must be a boolean value')
];

// Health check route
router.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Authentication routes
router.post('/auth/register', authLimiter, registerValidation, authController.register);
router.post('/auth/login', authLimiter, loginValidation, authController.login);
router.post('/auth/logout', auth, authController.logout);
router.post('/auth/refresh-token', authController.refreshToken);
router.post('/auth/forgot-password', authLimiter, [
  body('email').isEmail().normalizeEmail().withMessage('Please provide a valid email')
], authController.forgotPassword);
router.post('/auth/reset-password', authLimiter, [
  body('token').notEmpty().withMessage('Reset token is required'),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
], authController.resetPassword);
router.post('/auth/verify-email', [
  body('token').notEmpty().withMessage('Verification token is required')
], authController.verifyEmail);

// User routes
router.get('/user/profile', auth, userController.getProfile);
router.put('/user/profile', auth, [
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Name must be between 2 and 50 characters'),
  body('email')
    .optional()
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email')
], userController.updateProfile);
router.delete('/user/account', auth, userController.deleteAccount);
router.post('/user/change-password', auth, [
  body('currentPassword').notEmpty().withMessage('Current password is required'),
  body('newPassword')
    .isLength({ min: 8 })
    .withMessage('New password must be at least 8 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('New password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')
], userController.changePassword);

// Todo routes
router.get('/todos', auth, generalLimiter, todoController.getTodos);
router.post('/todos', auth, generalLimiter, todoValidation, todoController.createTodo);
router.get('/todos/stats', auth, generalLimiter, todoController.getTodoStats);
router.get('/todos/search', auth, generalLimiter, todoController.searchTodos);
router.get('/todos/categories', auth, generalLimiter, todoController.getCategories);
router.get('/todos/:id', auth, generalLimiter, todoController.getTodoById);
router.put('/todos/:id', auth, generalLimiter, updateTodoValidation, todoController.updateTodo);
router.delete('/todos/:id', auth, generalLimiter, todoController.deleteTodo);
router.patch('/todos/:id/toggle', auth, generalLimiter, todoController.toggleTodoComplete);
router.post('/todos/bulk-update', auth, generalLimiter, [
  body('todoIds')
    .isArray({ min: 1 })
    .withMessage('Todo IDs must be a non-empty array'),
  body('updates')
    .isObject()
    .withMessage('Updates must be an object')
], todoController.bulkUpdateTodos);
router.delete('/todos/bulk-delete', auth, generalLimiter, [
  body('todoIds')
    .isArray({ min: 1 })
    .withMessage('Todo IDs must be a non-empty array')
], todoController.bulkDeleteTodos);

// Sync routes for offline capability
router.post('/sync/todos', auth, generalLimiter, [
  body('todos')
    .isArray()
    .withMessage('Todos must be an array'),
  body('lastSyncTimestamp')
    .optional()
    .isISO8601()
    .withMessage('Last sync timestamp must be a valid date')
], todoController.syncTodos);
router.get('/sync/todos/:timestamp', auth, generalLimiter, todoController.getTodosAfterTimestamp);

// Export/Import routes
router.get('/export/todos', auth, rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5, // limit each IP to 5 exports per hour
  message: {
    error: 'Too many export requests, please try again later.'
  }
}), todoController.exportTodos);

router.post('/import/todos', auth, rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // limit each IP to 3 imports per hour
  message: {
    error: 'Too many import requests, please try again later.'
  }
}), todoController.importTodos);

// Webhook routes for real-time updates
router.post('/webhooks/todo-updated', todoController.handleTodoWebhook);

// Error handling middleware for routes
router.use((error, req, res, next) => {
  console.error('Route error:', error);
  
  if (error.type === 'entity.parse.failed') {
    return res.status(400).json({
      error: 'Invalid JSON payload'
    });
  }
  
  if (error.type === 'entity.too.large') {
    return res.status(413).json({
      error: 'Request payload too large'
    });
  }
  
  res.status(500).json({
    error: 'Internal server error'
  });
});

// 404 handler for API routes
router.use('*', (req, res) => {
  res.status(404).json({
    error: 'API endpoint not found',
    path: req.originalUrl,
    method: req.method
  });
});

module.exports = router;